#!/usr/bin/python3
# -*- coding: utf-8 -*-

from paho.mqtt.client import Client as MqttClient
from pyModbusTCP.client import ModbusClient
import threading
import logging
import signal
import time
import sys
import os


# modbus tcp server
MODBUS_HOST = '192.168.100.100'
MODBUS_PORT = 502

# mqtt broker
MQTT_HOST = 'mosquitto'
MQTT_PORT = 1883


state = {
    'manual': None,            # (RW) manual mode: ON, OFF
    'bypass': {
        'relay': None,         # (RO) status: ON, OFF
        'mode': None,          # (RW) ON, OFF, AUTO
        'auto': {
            'inside': None,    # (RW) above this temperature, BYPASS is ON ( Tinside > )
            'outside': None,   # (RW) above this temperature, BYPASS is ON ( Toutside > )
        },
    },
    'heater': {
        'mode': None,          # (RW) OFF, ELECTRIC, WATER, FREON_COOLER
        'temp': None,          # (RW) heater temp (target)
        'level': None,         # (RO) heater output level
    },
    'speed': {
        'manual': None,        # (RW) speed in manual mode
        'supply': None,        # (RO) supply fan speed
        'extract': None,       # (RO) extract fan speed
    },
    'temp': {
        'outside': None,       # (RO) outside (input)
        'extract': None,       # (RO) extract temp
        'supply': None,        # (RO) supply temp
    },
    'reconnected': False,      # just reconnected
}


def terminate(signum, frame):
    sys.exit(0)


def modbus_check(modbus):
    if not modbus.is_open():
        logging.info('[modbus] connecting...')
        if modbus.open():
            state['reconnected'] = True
            logging.info('[modbus] connected')
        else:
            logging.warning('[modbus] connect failed')


def mqtt_connected(mqtt, userdata, flags, rc):
    if rc == 0:
        mqtt.subscribe('msr23/bypass/auto/+/set')
        mqtt.subscribe('msr23/bypass/+/set')
        mqtt.subscribe('msr23/heater/+/set')
        mqtt.subscribe('msr23/+/set')


def mqtt_publish(mqtt, topic, payload, retain=False, quiet=False):
    if not quiet:
        logging.info('[mqtt] > %s = %s', topic, payload)
    mqtt.publish(topic, payload, retain=retain)


def get_temp(raw):
    # convert unsigned short to signed
    temp = raw - 65536 if raw > 32767 else raw
    # divide
    return float(temp) / 10.0


def mqtt_received(mqtt, userdata, message):
    modbus, lock = userdata
    payload = message.payload
    topic = message.topic

    logging.info('[mqtt] received %s = %s', topic, payload.decode('utf-8'))

    # enable / disable manual control
    if topic == 'msr23/manual/set' and payload in (b'0FF', b'ON'):
        with lock:
            modbus_check(modbus)
            state['manual'] = (payload == b'ON')
            modbus.write_single_register(37, 0 if state['manual'] else 2)
            mqtt_publish(mqtt, 'msr23/manual', payload.decode('utf-8'), retain=True)

        return

    # set fan speed
    if topic == 'msr23/speed/set' and \
       payload.replace(b'.', b'', 1).isdigit() and 0 <= int(float(payload)) <= 100:
        with lock:
            modbus_check(modbus)
            speed = int(float(payload))
            state['speed']['manual'] = speed
            modbus.write_single_register(34, speed)
            mqtt_publish(mqtt, 'msr23/speed/manual', str(speed), retain=True)

        return

    # set bypass mode
    if topic == 'msr23/bypass/mode/set' and payload in (b'OFF', b'ON', b'AUTO'):
        with lock:
            modbus_check(modbus)
            state['bypass']['mode'] = payload.decode('utf-8')
            modbus.write_single_register(12, (b'OFF', b'ON', b'AUTO').index(payload))
            mqtt_publish(mqtt, 'msr23/bypass/mode', payload.decode('utf-8'), retain=True)

        return

    # set bypass temp outside
    if topic == 'msr23/bypass/auto/outside/set' and \
       payload.replace(b'.', b'', 1).isdigit() and 5 <= float(payload) <= 40:
        with lock:
            modbus_check(modbus)
            state['bypass']['auto']['outside'] = int(float(payload))
            modbus.write_single_register(13, int(float(payload)))
            mqtt_publish(mqtt, 'msr23/bypass/auto/outside', str(int(float(payload))), retain=True)

        return

    # set bypass temp inside
    if topic == 'msr23/bypass/auto/inside/set' and \
       payload.replace(b'.', b'', 1).isdigit() and 15 <= float(payload) <= 40:
        with lock:
            modbus_check(modbus)
            state['bypass']['auto']['inside'] = int(float(payload))
            modbus.write_single_register(14, int(float(payload)))
            mqtt_publish(mqtt, 'msr23/bypass/auto/inside', str(int(float(payload))), retain=True)

        return

    # set bypass mode
    if topic == 'msr23/heater/mode/set' and payload in (b'OFF', b'ELECTRIC', b'WATER', b'FREON_COOLER'):
        with lock:
            modbus_check(modbus)
            state['heater']['mode'] = payload.decode('utf-8')
            modbus.write_single_register(17, (b'OFF', b'ELECTRIC', b'WATER', b'FREON_COOLER').index(payload))
            mqtt_publish(mqtt, 'msr23/heater/mode', payload.decode('utf-8'), retain=True)

        return

    # set heater temp
    if topic == 'msr23/heater/temp/set' and \
       payload.replace(b'.', b'', 1).isdigit() and 15 <= float(payload) <= 50:
        with lock:
            modbus_check(modbus)
            state['heater']['temp'] = int(float(payload))
            modbus.write_single_register(18, int(float(payload)))
            mqtt_publish(mqtt, 'msr23/heater/temp', str(int(float(payload))), retain=True)

        return


def main():
    # create lock
    lock = threading.Lock()

    # create modbus client
    modbus = ModbusClient()
    modbus.host(MODBUS_HOST)
    modbus.port(MODBUS_PORT)

    # create mqtt client
    mqtt = MqttClient('msr23')
    mqtt.on_message = mqtt_received
    mqtt.on_connect = mqtt_connected
    mqtt.user_data_set((modbus, lock))
    mqtt.connect_async(MQTT_HOST, port=MQTT_PORT, keepalive=30)
    mqtt.loop_start()

    temp_report = 0

    while True:
        time.sleep(1)

        with lock:
            modbus_check(modbus)
            data1 = modbus.read_holding_registers(12, 10)
            data2 = modbus.read_holding_registers(34, 14)

        if not data1 or not data2:
            continue

        now = time.monotonic()

        # parse modbus registers
        bypass_mode = ('OFF', 'ON', 'AUTO')[data1[0]]
        bypass_outside = data1[1]
        bypass_inside = data1[2]
        heater_mode = ('OFF', 'ELECTRIC', 'WATER', 'FREON_COOLER')[data1[5]]
        heater_temp = data1[6]
        heater_level = data1[9]
        manual_mode = ('ON', None, 'OFF')[data2[3]]
        bypass_relay = ('OFF', 'ON')[data2[8]]
        speed_manual = data2[0]
        speed_supply = data2[1]
        speed_extract = data2[2]
        temp_outside = get_temp(data2[10])
        temp_extract = get_temp(data2[12])
        temp_supply = get_temp(data2[13])

        # detect device reset / power loss:
        # manual fan speed updated to 29% after successful reconnect
        if state['reconnected'] and \
           state['manual'] is not None and \
           state['manual'] and manual_mode and \
           state['speed']['manual'] is not None and \
           state['speed']['manual'] != 29 and \
           speed_manual == 29:
            # restore manual speed settings
            state['reconnected'] = False
            logging.info('[modbus] device reset detected')

            speed_manual = state['speed']['manual']
            speed_supply = state['speed']['supply']
            speed_extract = state['speed']['extract']
            logging.info('[modbus] restoring manual speed {}'.format(speed_manual))
            with lock:
                modbus_check(modbus)
                modbus.write_single_register(34, speed_manual)

            continue

        # reset reconnected state
        state['reconnected'] = False

        # update state values
        if state['bypass']['mode'] != bypass_mode:
            state['bypass']['mode'] = bypass_mode
            mqtt_publish(mqtt, 'msr23/bypass/mode', bypass_mode, retain=True)

        if state['bypass']['auto']['outside'] != bypass_outside:
            state['bypass']['auto']['outside'] = bypass_outside
            mqtt_publish(mqtt, 'msr23/bypass/auto/outside', str(bypass_outside), retain=True)

        if state['bypass']['auto']['inside'] != bypass_inside:
            state['bypass']['auto']['inside'] = bypass_inside
            mqtt_publish(mqtt, 'msr23/bypass/auto/inside', str(bypass_inside), retain=True)

        if state['heater']['mode'] != heater_mode:
            state['heater']['mode'] = heater_mode
            mqtt_publish(mqtt, 'msr23/heater/mode', heater_mode, retain=True)

        if state['heater']['temp'] != heater_temp:
            state['heater']['temp'] = heater_temp
            mqtt_publish(mqtt, 'msr23/heater/temp', str(heater_temp), retain=True)

        if state['heater']['level'] != heater_level:
            state['heater']['level'] = heater_level
            mqtt_publish(mqtt, 'msr23/heater/level', str(heater_level), retain=True)

        if state['manual'] != manual_mode:
            state['manual'] = manual_mode
            mqtt_publish(mqtt, 'msr23/manual', manual_mode, retain=True)

        if state['bypass']['relay'] != bypass_relay:
            state['bypass']['relay'] = bypass_relay
            mqtt_publish(mqtt, 'msr23/bypass/relay', bypass_relay, retain=True)

        if state['speed']['manual'] != speed_manual:
            state['speed']['manual'] = speed_manual
            mqtt_publish(mqtt, 'msr23/speed/manual', str(speed_manual), retain=True)

        if state['speed']['supply'] != speed_supply:
            state['speed']['supply'] = speed_supply
            mqtt_publish(mqtt, 'msr23/speed/supply', str(speed_supply), retain=True)

        if state['speed']['extract'] != speed_extract:
            state['speed']['extract'] = speed_extract
            mqtt_publish(mqtt, 'msr23/speed/extract', str(speed_extract), retain=True)

        if now >= temp_report or abs(temp_outside - state['temp']['outside']) > 0.3:
            state['temp']['outside'] = temp_outside
            mqtt_publish(mqtt, 'msr23/temp/outside', str(temp_outside), quiet=True)

        if now >= temp_report or abs(temp_extract - state['temp']['extract']) > 0.3:
            state['temp']['extract'] = temp_extract
            mqtt_publish(mqtt, 'msr23/temp/extract', str(temp_extract), quiet=True)

        if now >= temp_report or abs(temp_supply - state['temp']['supply']) > 0.3:
            state['temp']['supply'] = temp_supply
            mqtt_publish(mqtt, 'msr23/temp/supply', str(temp_supply), quiet=True)

        if now >= temp_report:
            temp_report = now + 60


if __name__ == '__main__':
    logging.basicConfig(stream=sys.stdout, level=logging.INFO,
                        format='%(asctime)s %(levelname)s %(message)s')

    if os.getenv('MQTT_HOST') is not None:
        MQTT_HOST = os.getenv('MQTT_HOST')

    if os.getenv('MQTT_PORT') is not None:
        MQTT_PORT = int(os.getenv('MQTT_PORT'))

    if os.getenv('MODBUS_HOST') is not None:
        MODBUS_HOST = os.getenv('MODBUS_HOST')

    if os.getenv('MODBUS_PORT') is not None:
        MODBUS_PORT = int(os.getenv('MODBUS_PORT'))

    if os.getpid() == 1:
        signal.signal(signal.SIGINT, terminate)
        signal.signal(signal.SIGTERM, terminate)
        signal.signal(signal.SIGQUIT, terminate)

    main()
